Distributed Quantum Computing: a Survey

Nowadays, quantum computing has reached the engineering phase, with fully-functional quantum processors integrating hundred of noisy qubits available. Yet – to fully unveil the potential of quantum computing out of the labs and into business reality – the challenge ahead is to substantially scale the qubit number, reaching orders of magnitude exceeding the thousands (if not millions) of noise-free qubits. To this aim, there exists a broad consensus among both academic and industry communities about considering the distributed computing paradigm as the key solution for achieving such a scaling, by envision multiple moderate-to-smallscale quantum processors communicating and cooperating to execute computational tasks exceeding the computational resources available within a single processing device. The aim of this survey is to provide the reader with an overview about the main challenges and open problems arising with distributed quantum computing, and with an easy access and guide towards the relevant literature and the prominent results from a computer/communications engineering perspective.

INTRODUCTION 

The Quantum Internet [1, 2] is envisioned as the final stage of the quantum revolution, opening new communication and computing capabilities. In synergy with the classical Internet, the Quantum Internet will connect quantum processors and devices to achieve capabilities that are provably impossible using classical communication. Within the last few years, a major effort is being undertaken by the research community and by the major ICT companies towards the Quantum Internet design and deployment.


Within the EU, The Quantum Flagship’s projects are developing some of the most advanced physical quantum computing and quantum communication platforms in the world [3]. Specifically, long-term ambition of the Quantum Internet Alliance project is to build a Quantum Internet that enables quantum communication applications between any two points on Earth [4]. In this decade, a quantum communication infrastructure (EuroQCI) will cover the whole EU, including its overseas territories [5]. Overseas, the US government opened a number of publicly funded centers for quantum research in the last decade [6]. One of them is Q-NEXT [7], whose mission is to “deliver quantum interconnects and establish a national foundry to provide pristine materials for new quantum devices”. Q-NEXT’s vision is to help developing the technology that will enable applications in secure communication, distributed sensing, and scaling quantum computers. Another US public center is the Hybrid Quantum Architectures and Networks (HQAN) [8], whose goal is “[tackling] the challenge of scaling quantum processors by pursuing an alternative paradigm: distributed quantum processing and networks composed of a hybrid architecture”. Furthermore, the Center for Quantum Networks (CQN) [9] is working directly on key challenges facing the construction of large-scale quantum networks. CQN’s goals include developing foundational technology – such as optical fibers, quantum repeaters, and switches – for metropolitan-scale quantum networks. But Quantum Internet research is not limited to western countries. China is actively advancing research on quantum communications, with technology implementations such as their quantum secure communication networks (regional “Trunks”) combined with their quantum satellite project (nicknamed Micius) [10]. It is estimated that there has been at least a 25 billion dollars Chinese government investment from the mid-1980s until 2022 into quantum technology [11]. One of Beijing’s aims for its 14th five-year plan, which ends in 2025, is to establish an intercity quantum demonstration network based on secure relays. Meanwhile, companies like IBM, Google, and Amazon are making significant investments in quantum computing and quantum networking. In May 2017, AT&T announced that it was working with the California Institute of Technology to build out its quantum networking technology to offer more secure communications. British Telecommunications (BT), Toshiba Research, ADVA Optical Networking, and the UK National Physical Laboratory, are collaborating to research and implement quantum encryption. 

I. Introduction II. DQC: Distributed Quantum Computing III. Quantum Preliminaries III-A. Qubits in a Nutshell III-B. Quantum Circuits III-C. Monolithic Execution III-D. Distributed Execution IV. Quantum Algorithms IV-A. Partitioning of Quantum Algorithms IV-B. Execution Management IV-C. Open Issues and Research Directions V. Quantum Networking V-A. Quantum Internet V-B. Quantum Teleportation V-C. Teledata vs Telegate V-D. Physical vs Virtual Quantum Link V-E. Open Issues and Research Directions VI. Quantum Compiling VI-A. Qubit Assignment VI-B. Non-local Gate Handling VI-C. Open Issues and Research Directions VII. Simulation Tools VII-A. Hardware-Oriented VII-B. Protocol-oriented VII-C. Application-oriented VII-D. Open Issues and Research Directions VIII. Conclusions and Future Perspectives VII-A. Industrial and Standardization Perspective VII-B. The Journey Ahead Fig. 2. Structure of the Survey 

In June 2018, BT announced that it had built a “quantum-secured” internet network that spanned between Cambridge, UK and BT’s laboratory in Ipswich, a distance of around 50 miles [13]. Amazon has recently established the AWS Center for Quantum Networking [14]. Researchers at the center will work on technologies like quantum repeaters and transducers, to allow for the creation of global quantum networks. Among the killer applications of the Quantum Internet [15], broad interest has been lately devoted to distributed quantum computing, where individual quantum processors – limited in the number of qubits – work together to solve computational tasks exceeding the computational resources available within a single processing device [12, 16–19]. This interest came as no surprise since – differently from classical distributed computing – a linear increase in the number of interconnected quantum processors unlocks an exponential increase of the quantum computational power [12, 17], as summarized in Figure 1. Unfortunately, the existing literature on distributed quantum computing is spread among different research communities – ranging from the physics through the communications/computer engineering to the computer science community – leading to a fundamental gap. The aim of this survey is precisely to bridge this gap, by introducing the reader to the astonishing and intriguing properties of distributed quantum computing. Stemming from this, in the following we shed the light on the distinctive characteristics of distributed quantum computing, with the objective of allowing the reader: i) to own the implications of the novel, astonishing and intriguing properties of quantum information for understanding the differences between distributed (classical) computing vs. distributed quantum computing; ii) to grasp the challenges as well as to appreciate the marvels arising with the paradigmatic shift from monolithic to distributed quantum computing

Indeed, due to the fast grow of this research field, such an understanding will serve the computer science community and the communications/computer engineering community alike to have an easy access and guide towards the relevant literature and to the prominent results, which will be of paramount importance for advancing the state-of-the-art. To the best of authors’ knowledge, a tutorial of this type is the first of its own. The paper is structured as depicted in Figure 2. Specifically, in Section 2, we introduce the rationale for distributed quantum computing, and we present the four different perspectives – algorithms, networking, compiling and simulation – discussed within the survey. Then, in Section 3, we provide the reader with a concise overview about quantum computing, with reference to the quantum circuit model. In Section 4, we focus on quantum algorithms, the extent to which they can be distributed as well as their execution management, once they are executed according to a distributed paradigm. In Section 5, we detail the pivotal role played by quantum networking for enabling distributed quantum computing, by discussing in detail the unconventional features of quantum communications. In Section 6, we describe some relevant approaches to the problem of compiling quantum algorithms for distributed execution, i.e., splitting them conveniently to fit the available networking and computing hardware. In Section 7, we provide an overview of the most advanced simulation tools for quantum networking, discussing their suitability for the design and analysis of distributed quantum computing architectures. Finally, we conclude our survey in Section 8 by first providing an industrial perspective on distributed quantum computing, and then by discussing the possible stages of distributing quantum computing development. 2 DQC: DISTRIBUTED QUANTUM COMPUTING Nowadays, all major quantum computing technologies – e.g., ion traps, superconductors, quantum dots, etc. – exhibit hard technological limitations on the number of qubits that can be embedded in a single quantum chip [16]. Accordingly, the consensus of both academic and industry communities for realizing large-scale quantum processors goes toward a quantum computing paradigm-shift, which consists in relying on a quantum network infrastructure to cluster together modular and small quantum chips in order to scale the number of qubits [1, 17, 20, 21]. The aforementioned vision is expected to be realized in a very near future. For instance, IBM plans to introduce in 2025 Kookaburra – a 1386 qubit multi-chip processor with communication link support for quantum parallelization – with three Kookaburra chips inter-connected into a 4158-qubit system [22]. With such modular systems, an ordinarily monolithic quantum computation can be “split into pieces” and executed on multiple inter-connected processors by following the distributed quantum computing (DQC) paradigm [12, 23]. Despite being expected further into the future, metropolitan-area and wide-area quantum networks are also under research and development [2426], which would enable DQC among geographically-distributed quantum device. This survey focuses on DQC, and it analyzes the state-of-the-art and challenges arising by looking at the DQC according to four main different perspectives, namely: algorithms, networking, compiling, and simulation. As illustrated in Figure 3, for each of these four pillars, the most relevant aspects are discussed. Regarding algorithms, the focus is on the crucial and specific challenges arising when moving from monolithic to distributed quantum computing, namely, quantum algorithm partitioning and execution management. Being DQC an application of quantum networking – namely, being some sort of (quantum) network a fundamental pre-requisite for any form of distributed (quantum) computing – through the survey we will shed the light on the challenges arising with internetworking different quantum processors, by introducing the reader to the fundamental differences between interconnecting remote classical processors versus interconnecting remote quantum processors. As regards to compiling, it deals with translating a hardware-agnostic description of the algorithm – namely, the quantum circuit – into a functionally equivalent description that takes into account the physical constraints of the underlying computing architecture [18]. Indeed, within the context of DQC, the compiling must account also for the network constraints, which impact on the strategy adopted for splitting the circuit into “portions” to be concurrently executed on the individual quantum processing units (QPUs)1. As a matter of fact, a key goal is to minimize the number of remote operations, i.e., operations involving different QPUs. Last but not least, the design of DQC architectures can be highly facilitated by adequate simulation tools, as discussed and detailed in the manuscript. 3 QUANTUM PRELIMINARIES In this section, we provide a short overview about quantum computing, with reference to the quantum circuit model. We refer the reader to [27] for a concise introduction to the peculiarities and the challenges arising with quantum information, whereas an overview about quantum computing and an in-depth treatise about quantum information and quantum computation are provided in [28, 29] and [30], respectively. 

3.2 Quantum Circuits The quantum circuit [30] is the most popular model of quantum computation, where quantum operators are described as quantum gates. More into details, by sequentially interconnecting different quantum gates, a quantum circuit models the processing of quantum information corresponding to a specific quantum algorithm is obtained [18]. Indeed, there exist several equivalent quantum circuits modeling the same computation with a different arrangement or different ordering of gates. A very simple example of quantum circuit is provided in Figure 5, where each horizontal line represents the time evolution of the state of a single (logical) qubit, with time flowing from left to right, dictating the order of execution of the different gates. Quantum gates (and, overall, quantum circuits) are described by unitary matrices relative to some basis, i.e., matrix 𝑈 such that 𝑈 †𝑈 = 𝐼 . It follows that quantum computation is reversible: it is always possible to invert a quantum computation. Some widely-used gates4 are reported in Table 1 and, as a matter of fact, every unitary operator 𝑈 on a single qubit can be formulated as: 𝑈 = 𝑒𝑖𝜃1 R𝑥 (𝜃2)R𝑦 (𝜃3)R𝑧 (𝜃4), 𝜃𝑖 ∈ R with R𝑖 denoting the 𝑖-axis rotation operator, defined in Table 1. More precisely, the possibility of implementing two arbitrary rotation operators is sufficient, as their combined application can be exploited to obtain the third type of rotation in (5). Among two-qubit gates, highly relevant are the controlled ones. The generic Controlled-U gate operates on two5 qubits, namely a control qubit (controlling the operation) and a target qubit (subjected to the operation). By denoting with |𝜑𝑐 ⟩ and |𝜑𝑡 ⟩ the control and target qubits respectively, the effect of the controlled U gate on the target qubit is the following: ( I |𝜑𝑡 ⟩ if |𝜑𝑐 ⟩ = |0⟩ U |𝜑𝑡 ⟩ if |𝜑𝑐 ⟩ = |1⟩ . (6) The most famous example of controlled gate is represented by the CNOT gate, which is a Controlled-U gate where the U gate is a Pauli-X one. The CNOT gate can be used to create or destroy entanglement among the inputs. Specifically, to obtain an entangled state, we may start from the separable input |00⟩ and, by applying H to the first qubit, obtaining (|00⟩ + |10⟩)/√ 2. Finally, by applying a CNOT gate (where the first qubit is the control one, as shown in Figure 5), the resulting state is exactly the Bell state given in (4), namely, (|00⟩ + |11⟩)/√ 2. Gates H, S and CNOT constitute the Clifford group [36], which can be simulated efficiently on a classical computer according to the Gottesman-Knill theorem [30]. The Clifford group is not universal, i.e., it cannot be used to describe any arbitrary quantum algorithm. However, it is sufficient to add the T gate to the Clifford group, and the resulting set is universal, yet it is not the only possible one. Indeed, each family of quantum computers – e.g., IBM Q one [37] – has its own specific universal gate set, which usually depends on the particulars of the underlying quantum hardware technology. It is worthwhile to note that, regardless the particulars of the adopted gate set, deterministic cloning of quantum states is impossible. Specifically, there exists no quantum gate (or circuit) able to make a perfect copy of an arbitrary unknown quantum state. Conversely, if the state is known in advance – specifically, if we know that the state belongs to some orthonormal basis such as {|0⟩ , |1⟩} or {|+⟩ , |−⟩} – we can design a specific quantum gate to clone that state. This fundamental property is known as no-cloning theorem, and it has deep impact on distributed quantum computing as we will discuss in Section 5. Another unconventional quantum phenomenon arises with the important operation constituted by measurement, through which information from a quantum state is extracted [38], as illustrated in Figure 6. In fact, according to the quantum measurement postulate, although a qubit may reside in a superposition of two orthogonal states as in (1), when we want to observe or measure its value, it collapses into one of the two orthogonal states |0⟩ – with probability |𝛼 |2 – and |1⟩ – with the probability |𝛽 |26. After its measurement/observation, the original quantum state collapses to the measured state. Hence, the measurement irreversibly alters the original qubit state [27]. 𝑞0 𝑞1 𝑞2 𝑞3 𝑞4 Quantum Processor Fig. 7. Coupling maps of a IBM Yorktown quantum processor [39, 40]. The five physical qubits stored within the processor are represented by circles. The arrows denote the possibility to realize a two-qubit CNOT gate between the five qubits. As an example, a CNOT between qubits 𝑞0 and 𝑞1 can be directly executed by the quantum processor, whereas a CNOT between qubits 𝑞0 and 𝑞2 cannot. Finally, it is worthwhile to mention that a quantum circuit exhibits three important quantitative features: the width, i.e., the number of qubits, the gate count and the depth, i.e., the longest path in the circuit. Each and all of them affect the overall quality of the computation result. To get an easy flavor about the aforementioned statement, it is enough to think that due to imperfect hardware the expected error propagation is upper bounded by 2(1− (1−𝑟 )𝑚) [41] where 0 ≤ 𝑟 < 1 is a constant independent of the qubit number and 𝑚 is the number of gates in the circuit

3.3 Monolithic Execution: Gate Synthesis and Circuit Compilation As mentioned in the previous subsection, even if there exists an uncountable number of quantum logic gates, the set of gates that can be executed on a certain quantum processor is limited, as a consequence of the constraints imposed by the underlying qubit technology [42]. In this case, any gate outside this reduced set must be obtained with a proper combination of the allowed gates through a process known as gate synthesis. As an example, IBM quantum processors are realized exploiting the superconducting technology, and any logical gate that can be run on current IBM quantum processors is built from a gate set composed by the controlled-not (CNOT) gate and four single-qubit gates (namely, I, R𝑍 , SX, X gates). Furthermore, regardless of the underlying qubit technology, the abstract qubits subjected to quantum gates as specified by the quantum circuit, known as logical qubits, should not be confused with the physical qubits embedded within a quantum processor [18]. With reference to the physical qubits, any quantum processor exhibits hardware constraints affecting the allowed interactions between them. As an example, CNOT gates cannot be applied to any physical qubit pair of an IBM quantum processor, but they are instead restricted7 to certain pairs. The allowed pairs are usually represented with the coupling map – namely, with a graph where vertices denote qubits and arrows denote the possibility of realizing a two-qubit CNOT gate between the connected qubits – as illustrated in Figure 7. From the above, it becomes clear that the monolithic execution of a quantum algorithm on a single quantum processor requires a circuit pre-processing known as quantum compiling [18, 43–45]. In a nutshell, compiling a quantum circuit is a two-step8 process where:

i) each logical qubit of the quantum circuit must be mapped onto one (or more, when adopting fault-tolerant techniques [46]) physical qubit of the quantum processor, and ii) each two-qubit gate – as instance, a CNOT – between physical qubits non-adjacent within the coupling map must be mapped into a computational-equivalent sequence of gates between adjacent physical qubits, as exemplified in Figure 8. Clearly, the overall process must be optimized to account for the key performance metrics affecting quantum computation [47–49]. Typically, this consists in minimizing the depth of the compiled circuit, namely, the equivalent quantum circuit satisfying all the constrains imposed by the quantum processor coupling map. 3.4 Distributed Execution So far, we focused on quantum circuits by abstracting from the particulars of the underlying computing technology. Indeed, we mentioned that the natively-available gates depends on the underlying hardware. Yet, this is not an issue since – as long as the available gate set is universal – any arbitrary gate can be implemented with a finite sequence of the available gates up to arbitrary accuracy [29]. From the above, we can safely assume that any quantum circuit can be directly executed on a given quantum processor, either in the original form or by properly replacing unavailable gates with sequences of available ones. But the task becomes significantly harder when we move from monolithic quantum computing to distributed quantum computing. Specifically, any universal gate set must include one multi-qubit gate – typically a 2-qubit gate such as the CNOT – and any quantum circuit of some interest includes multi-qubit gates as well. As a consequence, as illustrated with the toy-model in Figure 9, a distributed quantum computation involves operations between qubit pairs across different end-nodes (i.e., non-local gates). At a first sight, this might seem not a big deal. Also (classical) distributed computing involves operations between classical information located at different processors. And these operations are performed by simply moving the information from one processor to another. So one might be tempted to believe that the same strategy can be adopted when it comes to distributed quantum computing. Unfortunately, this is not true: quantum information requires a paradigm shift for dealing with interprocessor communications, and the rationale for this would be deeply discussed in the next sections.

4 QUANTUM ALGORITHMS There exists several quantum algorithms known or expected to outperform classical algorithms for problems spanning different areas, including cryptography, search and optimization, simulation of quantum systems and learning [50]. Remarkably, most known quantum algorithms use a combination of algorithmic paradigms – namely, sub-routines – specific to quantum computing [37]. These paradigms include the Quantum Fourier Transform (QFT) [51], the Grover Operator (GO) [52], the Harrow/Hassidim/Lloyd (HHL) method for linear systems [53], Variational Quantum Algorithms (VQA) [54], and direct Hamiltonian simulation (SIM). A prominent example is Shor’s algorithm for integer factorization [51], which is based on QFT, illustrated by the quantum circuit in Figure 10. For most practical applications, quantum algorithms require large quantum computing resources – in terms of qubit number – much larger than those available with current noisy intermediate-scale quantum (NISQ) processors. For example, the recently announced IBM Quantum Osprey device has 433 qubits, which is an impressive progress with respect to state-of-the-art quantum processors, but not yet sufficient, as an example, for running practical implementations of Shor’s algorithm9. Distributed quantum computing is envisioned as a scalable approach for increasing the number of qubits available for computational tasks. However, moving from monolithic to distributed quantum computing implies crucial and specific challenges. 4.1 Partitioning of Quantum Algorithms A first issue that arises with quantum algorithms is whether a given algorithm – equivalently, a given quantum circuit – is natively suitable for distributed execution. More specifically, a perfectly distributable quantum algorithm is a quantum algorithm that can be split into autonomous parts that do not interact – or, at least, weakly interact – with each others. If this is the case, each part can be assigned to some quantum processor, and each processor can contribute autonomously to the overall computation without introducing communication overhead for interacting with other processors. Unfortunately, this is not the usual case. As an example, let us consider the QFT algorithm, whose circuit is given in Figure 10, notably used as sub-routine in many quantum algorithms e.g., Shor’s algorithm and the quantum phase estimation algorithm – as mentioned above. From Figure 10, it is easy to assess that QFT requires each qubit to strongly interact with all the other qubits through controlled R𝑛 gates. Hence, QFT can be considered as the archetype of monolithic quantum algorithms, namely, of an algorithm not natively-suitable for distributed execution.

As we anticipated in Section 2, to distribute a monolithic quantum algorithm, a quantum compiler must be used to find the best breakdown, i.e., the one that minimizes the number of gates that are applied to qubits stored at different devices. Quantum compilation is reviewed in Section 6. Here we discuss some literature that addresses the partitioning of relevant quantum algorithms, using techniques that are tailored to the specific considered algorithms rather than general-purpose. These works may represent a good reference for a comparative evaluation of quantum compilers. In [56], Neumann et al. present two distribution schemes for the quantum phase estimation algorithm, give the resource requirements for both and show that using less noisy shared entangled states results in a higher overall fidelity. Introduced by Kitaev [57], the quantum phase estimation algorithm returns an approximation of an eigenvalue of a given unitary 𝑈 and a corresponding eigenvector. It has numerous applications, including Shor’s algorithm [51]. The solution proposed by Neumann et al. is based on the distributed version of the QFT circuit, obtained by means of non-local controlled 𝑈 -gates10. Another example of distributable quantum algorithm is the Variational Quantum Eigensolver (VQE), a VQA that can be used to estimate ground state energies of molecular chemical Hamiltonians. In [59], DiAdamo et al. provide a Local to Distributed Circuit algorithm that, given a circuit representation as a series of layers and a mapping of qubits, searches for any control gates where the control and target are physically separated between two QPUs. When found, the algorithm inserts, between the current layer and next layer in the circuit, the necessary steps to perform the control gate in a nonlocal way11. The size (maximum number of qubits) of the achievable Ansatz state for the VQE algorithm grows linearly with the number of QPUs, with slope linearly increasing with the number of qubits per QPU. The depth of the resulting quantum circuit is Ω(𝑛), meaning it has a tight upper and lower bound proportional to the number 𝑛 of qubits. In [61], the authors present a distributed adder and a distributed distance-based classification algorithm. Both applications are framed in a way where a quantum server and 𝐾 other quantum nodes interact, with specific behaviors. In particular, the server is responsible for orchestrating the computation by means of non-local CNOT gates, while the 𝐾 parties provide inputs. It is possible to reframe these applications, such that the proposed quantum circuits are considered as monolithic and subsequently split in 𝐾 +1 parts to be submitted for execution to a quantum network.

4.2 Execution Management Another challenge is related to the execution management of distributed quantum computations. In general, given a collection P of quantum circuit instances to be executed, this collection should be partitioned into non-overlapping subsets P𝑖 , such that P = ∪𝑖 P𝑖 . One after the other, each subset will be assigned to the available QPUs. In other words, for each execution round 𝑖, there exists a schedule 𝑆 (𝑖) that maps some quantum circuit instances to the quantum network. If DQC is supported, some quantum circuit instances may be split into sub-circuit instances, each one to be assigned to a different QPU, as illustrated in Figure 11). A QPU scheduling algorithm that partially address this service was proposed by Parekh et al. [23]. Such an algorithm is based on a greedy approach, trying to fill all available QPUs while minimizing the number of distributed quantum circuit instances. Here the partitioning of quantum circuit instances is arbitrary, not taking into account the features of the programs. Recalling Section 4.1, we stress that partitioning should be an orthogonal service with respect to QPU scheduling. It is worth noting that the QPU scheduling plane must be clearly separated from the networking plane. We demand that any subset of the available QPUs can be the target of any quantum computation, provided that the total number of physical qubits fits the circuit width. This means that the underlying network should allow to create entangled quantum states across any two QPUs. Technical details on entanglement distribution are presented in Section 5. Here we recall a recent work by Cicconetti et al. [62], which investigates the requirements and objectives of DQC from the perspective of quantum network provisioning. In particular, the authors elaborate on two different classes of traffic, namely constant-rate flows and DQC applications. 4.3 Open Issues and Research Directions Future directions are both theoretical and practical. Despite a considerable amount of work on the fundamentals of distributed quantum computing [63–65], an ultimate theory of distributable quantum algorithms is still missing. It is known that the quantum circuit model and the DQC model are equivalent up to polylogarithmic depth overhead [64], but a general framework for ranking quantum algorithms in terms of distributability has not been defined. To this purpose, it is necessary to provide a quantitative definition of quantum circuit distributability. Regarding execution management, the broad literature on job scheduling for high performance computing may be a starting point, but it is clear that the peculiarities of quantum computing – quantum parallelism, no-cloning, entanglement, etc. – demand for novel and specific strategies for the efficient execution of concurrent distributed quantum computations. A trade-off between the complexity of the distributed quantum circuit and the physical distance between quantum processors is also envisaged.

To compare different deployments and schedules, DQC-specific key performance indicators must be defined. Recently, two frameworks with similar names have been proposed almost at the same time, namely Quantum Network Utility Maximization (QNUM) [66] and Quantum Network Utility (𝑈𝑄𝑁 ) [67]. While QNUM is specifically tailored to the evaluation of entanglement routing schemes in quantum networks (see Section 5 for details about entanglement), 𝑈𝑄𝑁 is more abstract, aiming to capture the social and economic value of quantum networks, for a variety of applications (from secure communications to distributed sensing). Incidentally, in [67] the example of DQC is studied in detail, through the lens of 𝑈𝑄𝑁 . More specifically, a quantum network utility metric is presented, which applies the Quantum Volume12 proposed in [68] to the 𝑈𝑄𝑁 framework. Such a metric quantifies the value derived from performing QC tasks, and it is viewed as a “quantum volume throughput”. source QPU bsm destination QPU |𝜓 ⟩ 𝐻 |Φ+⟩ 𝑋 𝑍 |𝜓 ⟩ Fig. 12. Pictorial representation of the quantum teleportation circuit. The first two wires belong to the source node, whereas the bottom wire belongs to the destination node. A generic state |𝜓 ⟩ is initially stored at the source, and a Bell state such as  Φ+ given in (4) must be distributed through a quantum link so that one entangled member is stored at the source and the other at the destination. Once the Bell state is available, the teleportation is obtained with some processing of |𝜓 ⟩ and the entangled member at the source, followed by two conditional gates on the entangled pair at the destination, depending on the measurement of the two qubits at the source. Each double line denotes the transmission of one classical bit – i.e., the measurement output – between the remote processors. The two classical bits are thus used as detailed in Table 2 for determining whether the two conditional gates X and Z must be applied to recover the original state |𝜓 ⟩ from the entangled member available at the destination. It differs from the quantum volume in two ways: i) it explicitly considers the rate at which non-local operations can be performed, and ii) it accounts for the utility derived simultaneously from tasks executed on different parts of the network.

5 QUANTUM NETWORKING 

As mentioned in the previous sections, when it comes to distributed quantum computing, qubits are distributed among multiple smaller quantum processors, interconnected by some sort of quantum network. Accordingly, whenever a quantum gate must operate on remote qubits – namely, qubits located in different quantum processors – some sort of communication primitive must be available for performing interprocessor operations. Unfortunately, this communication primitive cannot be easily accomplished through classical protocols. Indeed, the different physical phenomena underlying quantum communications impose a paradigm shift. To better understand the above statement, in the following we shed the light on the challenges arising with networking different quantum processors. To this aim, in the following we first substantiate in Section 5.1 the fundamental differences arising with interconnecting remote classical processors versus interconnecting remote quantum processors. Then, in Section 5.2 we introduce the marvels of quantum teleportation, which represents the underlying communication functionality enabling remote quantum operations. Stemming from this, in Section 5.3 we discuss the two possible strategies – namely, telegate and teledata – for implementing quantum gates between remote qubits. Then, in Section 5.4 we present a key strategy – referred to as entanglement swapping – for virtually-augmenting the connectivity among different quantum processors. And finally, in Section 5.5, we discuss the open problems arising with interconnecting remote quantum processors. 5.1 Quantum Internet According to the on-going IETF RFC draft on Quantum Internet architectures [69], the Quantum Internet can be defined as an interconnection of heterogeneous13 quantum networks, able to exchange qubits and to generate and share entangled states among themselves. Hence, the Quantum Internet services ground on the manipulation and transmission of qubits as well as on the distribution of entangled states. This, in turn, imposes several challenges with no-counterpart in classical network and that cannot be solved through existing classical protocols. As an example, Internet (and classical networks in general) extensively relies on the possibility of freely duplicating information. But this basic assumption does not hold when it comes to the Quantum Internet [70, 71] accordingly to the no-cloning theorem14. Furthermore, according to the measurement postulate, even the simple action of measuring a qubit – i.e., reading the quantum information stored within – irreversibly alters its quantum properties, such as superposition and entanglement. The above peculiarities of quantum mechanics have deep implications on the design of quantum communication techniques for the Quantum Internet [1]. To further elaborate on the above statement, let us clarify that it is possible to map a qubit into a photon degree of freedom by directly transmitting this qubit to a remote node via a fiber link or free space. However, if the traveling photon is lost due to attenuation or it is corrupted by decoherence15, the associated quantum information cannot be recovered via a measuring process or by re-transmitting a copy of the original information. As a consequence, the techniques mitigating the imperfections imposed on the qubits cannot be directly borrowed from classical communications [27]. Thankfully, quantum entanglement [73] can be exploited as a communication resource to face with the aforementioned challenges. Indeed, entanglement enables a communication technique, known as quantum teleportation, for transmitting an unknown qubit without the physical transfer of the particle storing the qubit, as described in the following. 5.2 Quantum Teleportation As introduced in Section 3, whenever two qubits are entangled, they exist in a shared state, such that any action on a qubit affects instantaneously the other qubit as well, regardless of the distance [70]. This unconventional correlation is exploited by the so-called quantum teleportation process [27], which enables the possibility of “transmitting” – namely, teleporting – an unknown qubit without the physical transfer of the particle storing the qubit.

More into details, quantum teleportation requires: i) an EPR pair, namely a pair of maximally entangled qubits such as the Bell state in (4), with one qubit of the pair distributed at the source node and the other qubit distributed at the destination; ii) local quantum operations both at the source and at the destination; iii) the transmission of two classical bits from the source to the destination. The circuital representation of the quantum teleportation process is illustrated in Figure 12. More into details, the source performs a pre-processing, namely, a Bell State Measurement (BSM) on both the unknown qubit encoding the information, say |𝜓 ⟩, to be transmitted and the entangled qubit. As represented in the gray box in the figure, the BSM consists of a CNOT gate – with the information qubit acting as control and the entangled qubit acting as target – followed by an Hadamard gate on the information qubit and, finally, a measurement of both the qubits. Then, the source transmits – though classical communications – two classical bits encoding the measurement outcomes of the BSM. Remarkably, after the BSM, the source quantum state has been already teleported at the destination. Nevertheless, the teleported state may have been undergone a phase and/or a bit-flip, with each flip event occurring individually with a probability equal to 0.25. Luckily, the measurement of the two qubits at the source allows the destination – once the measurement outcomes have been received through a classical communication channel – to determine whether these flip events occurred. Hence, the destination performs a post-processing to reconstruct the original state |𝜓 ⟩, as detailed in Table 2. In conclusion, by pre-sharing a maximally-entangled pair of qubits16, two nodes can reliably exchange quantum information through the teleportation process [74], which represents the underlying communication functionality enabling remote quantum operations, as further elaborated in the following subsection. 5.3 Teledata vs Telegate In distributed quantum computing, quantum teleportation constitutes the fundamental communication primitive underlying the communication paradigms known as TeleData and TeleGate [75], which generalize the concept of moving quantum states among remote devices. To provide concrete examples of the TeleData and TeleGate concepts, we must classify qubits within a QPU either as communication qubits or as data qubits [12]. Specifically, within each quantum processor, a subset of qubits is reserved for inter-processor communications and we refer to these qubits as communication qubits [69], to distinguish them from the remaining qubits within the device devoted to processing/storage, which we refer as data qubits. More into detail, entanglement distribution among network nodes requires that at least one qubit at each processor, referred to as communication qubit, must be reserved for the generation of the entangled state [69]. Clearly, the more communication qubits are available within a network node, the more entanglement resource is available at that node, with an obvious positive effect on entanglement rate achievable by that node [70]. But the more communication qubits are available, the less data qubits are available for quantum computing. As an example, consider two quantum processors interconnected via a quantum network as depicted in Figure 13. Qubits 𝑞3 and 𝑞 ′ 0 are communication qubits and any interaction between the two remote processors is carried out by exploiting them via either a TeleData or a TeleGate process. With a TeleData, quantum information stored within a data qubit at the first processor, say |𝜑⟩ in 𝑞4 in Figure 13a, is teleported into a communication qubit of the second processor, say 𝑞 ′ 0 in the same figure. Once the quantum state |𝜑⟩ is teleported in 𝑞 ′ 0, any remote operation – originally involving 𝑞4 and some data qubits at the second processor – can be now implemented through local operations as shown with the last CNOT in Figure 13b. It must be noted, though, that whether the teleported quantum state should subsequently interact with data qubits at the first processor, a new teleportation process must be performed for teleporting the quantum state back to the first processor. TeleData is not the only available option for implementing remote operations. In fact, a TeleGate enables to execute a direct gate between qubits belonging to remote processors by exploiting again entanglement. As instance, a remote CNOT with data qubit 𝑞4 and 𝑞1 0 in Figure 13a acting as control and target, respectively, can be implemented with local CNOTs at each quantum processor, as shown with the quantum circuit in Figure 13c. 5.4 Physical vs Virtual Quantum Links From Figure 13, one might assume that distributed quantum computing requires a fully-connected network topology – namely, that each quantum processor must be directly inter-connected with all the other processors – as a consequence of the unconventional characteristics of quantum information. In other words, one might assume the connectivity between quantum processors strongly dependent on the availability of a direct entanglement generation and distribution architecture. As a matter of fact, the very opposite is true. Distributed quantum computing can exploit a strategy called entanglement swapping [42] and summarized in Fig 14 – to implement a remote CNOT between qubits stored at remote processors, even if the processors are not directly connected through a quantum link. In a nutshell, to distribute a Bell state between remote processors – say quantum processor #1 and #3 in Figure 14a – two Bell states must be first distributed through the quantum links so that one Bell state is shared between the first processor and an intermediate node and another Bell state is shared by the same intermediate node and the second processor. Then, by performing a BSM on the communication qubits at the intermediate node – i.e., qubits 𝑞′ 0 and 𝑞′ 3 in Figure 14b – a Bell state is obtained at the remote communication qubits 𝑞3 and 𝑞′′ 0 in Figure 14b – by applying some local processing at the remote nodes depending on the (classical) output of the Bell state measurement. From the above, it becomes clear that entanglement swapping significantly increases the connectivity within the virtual quantum processor. And the higher is the number of available quantum processors, the higher is the number of possible interactions. Indeed, the number of additional interactions via entanglement swapping scales linearly with the number of available processors when only two communication qubits are available at each intermediate processor. If this constraint is relaxed, the number of additional interactions via entanglement swapping scales more than linearly. 5.5 Open Issues and Research Directions Stemming from the discussion carried out in the previous subsections, here we summarize some fundamental open issues and research directions towards the interconnection of different quantum processors for enabling distributed quantum computing. First, in Section 5.3 we introduced the two possible strategies – TeleGate and TeleData – for implementing quantum gates between remote qubits. From a communication resource perspective, TeleData and TeleGate consume the same amount of quantum and classical resources, namely one EPR pair and the transmission of two classical bits. Yet the overall performance of the two strategies depends on a range of factors, including i) the pattern of remote operations exhibited by the quantum circuit to be executed, ii) the characteristics of the network interconnecting the remote quantum processors, and iii) the ratio between data and communication qubits [70, 75]. With reference to the latter factor, a fundamental trade-off arises [18]. Specifically, each remote operation – regardless whether it is implemented with a TeleData or a TeleGate – consumes the entangled resource. Consequently, a new Bell state must be distributed between the remote processors before another remote operation could be executed. Hence, the more communication qubits are available within each processor, the more remote operation can be executed in parallel, reducing the communication overhead induced by the distributed computation. But the more communication qubits, the less data qubits are available for computing in each processor. Accordingly to the above reasoning, the selection of the set of communication qubits is a crucial task for distributed quantum computing, with profound effects on the overall performance of the distributed computation. As a matter of fact, the fundamental role played by communication qubits is further stressed by the augmented connectivity enabled by entanglement swapping, discussed in Section 5.4. Indeed, it must be acknowledged that such an augmented connectivity does not come for free. Entanglement swapping consumes the Bell states at each intermediate processor. And the longer is the path between the two processors involved in the remote operation, the higher is the number of consumed Bell states. Clearly, the more Bell states are devoted to entanglement swapping, the less Bell states are available for implementing remote operations between neighbor quantum processors. Hence, a trade-off between “augmented connectivity” and “EPR cost” arises with entanglement swapping [18], and the impact of this trade-off on the overall performance of distributed quantum computing must be carefully accounted for. Another fundamental issue arising with networking remote quantum processors is represented by noise and imperfections affecting the quality of the distributed Bell states. Clearly the noisier is the distributed Bell state, the noisier is the overall distributed quantum computation. Luckily, a well-known technique for counteracting the noise impairments affecting the entanglement generation/distribution process is constituted by entanglement distillation (also known as entanglement purification) [63, 76–81]. Accordingly, as long as the “quality” of the noisy entanglement exceeds a certain threshold, it is possible to purify multiple imperfect Bell states into a single “almostmaximally entangled” pair, albeit at the price of consuming multiple noisy entangled states within the process. From the above, it follows that one of two orthogonal resources must be exploited for implementing the distillation process, namely, time or space. More into details, time-expensive distillation requires multiple rounds of entanglement generation and distribution, with each round involving few17 communication qubits. Conversely, space-expensive distillation can be completed with few rounds, but with each round involving several communication qubits. Hence, there exists a fundamental trade-off between i) quality of the overall computation, ii) delay induced by entanglement distillation, and iii) communication qubits reserved for distilling a high-quality Bell state. 6 QUANTUM COMPILING As mentioned in Section 3.3, quantum compilation means translating an input quantum circuit into the most efficient equivalent of itself, considering the characteristics of the device(s) that will execute the computation and minimizing the number of required multi-qubit gates. An example of quantum compilation is provided with Figure 15, where the original quantum circuit is translated into the compiled one to account for the coupling characteristics of IBM Yorktown quantum processors, shown in Figure 7. Clearly, as long as the hardware provides a universal set of operations, there exists a feasible transformation. Compilers are well-established in NISQ architectures, because of their role as intermediary between the user and the hardware. Specifically, in designing a quantum algorithm using the quantum circuit formalism introduced in Section 3.2, the designer is generally focused on expressing the computation required by the algorithm with a circuit that minimizes the number of utilized qubits and gates, regardless from the particulars of the quantum hardware that will execute the circuit. This abstract circuit is then mapped to a circuit to be executed on a specific quantum hardware by means of a suitable compiler. Clearly, introducing such an abstract circuit has two main advantages: i) the user can focus on the logic of the circuit, namely, on the essence of the quantum algorithm, without caring too much about the hardware constraints, and ii) the designed quantum circuit is portable, in theory, to any quantum back-end. Intuitively, a circuit transformation may introduce some overhead, in terms of number of operations and noise. In DQC architectures, there is also a non-negligible communication cost, as discussed in Section 5. Therefore, the compiler faces an optimization problem, i.e., finding a feasible transformation while minimizing the overhead. In general, this problem is known to be NP-hard [43, 82], even for the case of a single processor. A fundamental issue in quantum compiling is related to qubit connectivity. From the perspective of the quantum algorithm designer, any qubit is assumed to be directly connected with any other qubit. i.e., any two-qubit gate can be placed across any qubit pair. However, even on a single quantum processor as introduced in Section 3.3, the actual connectivity degree is usually low, to mitigate the noise caused by cross-talking phenomena [83]. Qubit routing refers to the task of modifying quantum circuits so that they satisfy the connectivity constraints of a target quantum computer. This involves inserting SWAP gates into the circuit so that the logical gates only ever occur between adjacent physical qubits. Of course, the number of SWAP gates should be minimized, in order keep the circuit depth reasonably small. The problem gets harder when considering distributed quantum processors, where the connectivity degree of the physical qubits can be even lower. For DQC to be effective and efficient, the quantum compiler must perform some preliminary ebit optimization (such as the one illustrated in Figure 16), then find the best split for the abstract circuit, i.e., the split that minimizes the overall communication cost required to execute the distributed circuit. At the same time, the quantum compiler must find the best local transformation for each piece of computation. From the above, it should be clear that designing an efficient compiler is a tough task. Because of this, a plethora of proposals to tackle the problem emerges from the literature. In future work, some of them may be combined to more sophisticated compilers. This already happened for local computing. For example, the quantum compiler from the IBM Q framework [84] has several layers of optimization, each tackling the problem from different perspectives. Most quantum compilers for DQC are characterized by two fundamental steps, namely qubit assignment and non-local gate handling. In the following, we present these two compilation steps, with reference to the most relevant literature. In Table 3, we compare some prominent DQCoriented quantum compiling strategies. To this purpose, we consider the programming language, the supported network topologies, the qubit assignment strategy, the non-local gate handling strategy, and the availability of an open source release of the software. In the remainder of the section, we first present some of the most representative strategies for qubit assignment and non-local gate handling. Then, we discuss some open issues. 6.1 Qubit Assignment An abstract circuit is composed by logical qubits, while a quantum processor is equipped with a register of physical qubits. An assignment, in its most basic form, is a one-to-one mapping between logical and physical qubits.18 Whether it is better to tackle it dynamically – changing the assignment while computing – or statically – defining the assignment at the beginning and keeping it for the whole execution of the computation – is an open problem, which also depends on whether the partition between communication qubits and computing qubits is static or dynamic. In DQC, qubit assignment is a general-purpose approach to the partitioning problem, introduced in Section 4.2. Specifically, for a given set of logical qubits, we need choose a partition that maps sub-sets of logical qubits to processors, while minimizing the number of required interactions among different sub-sets, as shown in Figure 17.  Several authors investigate this research direction [18, 85–87]. The reader will find in these works different proposals to address the qubit assignment problem. Not all the papers match in the minimum assumptions for the technology. Specifically, as described in Section 5, we are at a stage where one need to make predictions on the most likely DQC architecture that will run in the next future. If one assumes any connectivity, the resulting model is general-purpose, but it is also hard to tackle. Restricting the connectivity to one that satisfies some properties makes the model less general, but a good set of assumptions in this direction may shape future implementations as well. Currently, the preferred line is to keep connectivity general [87]. Andrés-Martínez and Heunen [85] propose to encode a logical circuit as an hypergraph. An hyperedge represents one ebit – i.e., one EPR shared between QPUs – which allows for a telegate to be performed. Qubit assignment works by minimizing the number of cuts, as each cut corresponds to an ebit. Sundaram et al. [86] present a two-step solution, where the first step is quantum assignment. Circuits are represented as edge-weighted graphs with qubits as vertices. The edge weights correspond to an estimation for the number of cat-entanglements11. The problem is then solved as a minimum k-cut, where partitions have roughly the same size. In [87], the same authors extend their approach to the case of an arbitrary-topology network of heterogeneous quantum computers by means of a Tabu search algorithm. In [88], by Daei et al., the circuit becomes an undirected graph with qubits as vertices, while edge weights correspond to the number of two-qubit gates between them. In [89], the authors represent circuits as bipartite graphs with two sets of vertices – one set for the qubits and one for the gates – and edges to encode dependencies of qubits and gates. Then for the qubit assignment problem, they propose a partitioning algorithm via dynamic programming to minimize the number of teledata operations. When qubit assignment is dynamic, new challenges – as well as new possibilities – arise. Nikahd et al. [90] propose a minimum k-cut partitioning algorithm formulated as an ILP optimization problem, to minimize the number of remote interactions. They use a moving window and apply the partitioning algorithm to small sections of the circuit, thus the partition may change with the moving window by means of teledata operations. In [18], Ferrari et al. consider the worst-case scenario of QPUs interconnected through an LNN topology19. Rather than focusing on the number of remote interactions, they design a sorting algorithm to reduce the depth overhead induced by such time consuming operations. The authors show that the overhead is upper-bounded by a factor that grows linearly with the number of qubits. Cuomo et al. in [91] model the compilation problem with an Integer Linear Programming formulation. The formulation is inspired to the vast theory on dynamic network problems. Authors managed to define the problem as a special case of quickest multi-commodity flow. Such a result allows to perform optimization by means of techniques coming from the literature, such as a time-expanded representation of the distributed architecture. 6.2 Non-local Gate Handling As described in Section 5, assumptions on the architectures not only concern connectivity. Predicting the best kind of remote interactions is of critical importance as well. In this sense, the general agreement is that the generation and distribution of entangled states is a fundamental resource to be used sparingly. Indeed, a common goal in the literature is to minimize the number of consumed ebits, as it is the main bottleneck to distributed quantum computation. To this aim, qubit assignment discussed above represents a starting point for further optimization steps, which now concern circuit manipulation. As described in Section 5.3, there are two main approaches for implementing non-local gates, namely teledata and telegate. The teledata approach is considered, for example, in [64, 65, 88, 89, 92]. Beals et al. [64] prove that the quantum circuit model, the quantum parallel RAM model, and the DQC model are equivalent up to polylogarithmic depth overhead. Other than this major result, they provide an algorithm for emulating circuits on any network graph. Brierley [65] focuses on 𝑛-qubit cyclic butterfly networks (a special case of hypercubic network) and proves that there is a sequence of local gates with depth 6 log 𝑛 such that the qubit at node 𝑎 is sent to node 𝜋 (𝑎) for all 𝑎 = 1, ..., 𝑛 and any permutation 𝜋 : [1, 𝑛] → [1, 𝑛]. In other words, the butterfly network can implement any quantum algorithm with an overhead of 6 log 𝑛. Such a network topology is suitable for multi-chip quantum devices or small controlled networks. In medium-scale or global networks, it is hard to implement such a constrained architecture. Daei et al. [88] propose a method to minimize the number of quantum teleportations between DQC partitions. The main idea is to turn the monolithic quantum circuit into an undirected weighted graph, where the weight of each edge represents the number of gates involving a specific pair of qubits for execution. Then, the graph is partitioned using the Kernighan-Lin (K-L) algorithm for VLSI design [94], so that the number of edges between partitions is minimized. Finally, each graph partition is converted to a quantum circuit. Davarzani et al. [89] propose an algorithm for minimizing teleportations consisting of two steps: first, the quantum circuit is converted into a bipartite graph model, and then a dynamic programming approach (DP) is used to partition the model into low-capacity quantum circuits. Finally, Dadkhah et al. [92] propose a heuristic approach to replace the equivalent circuits in the initial quantum circuit. Then, they use a genetic algorithm to partition the placement of qubits so that the number of teleportations could be optimized for the communications of a DQC. The telegate direction is pursued, for example, in [85, 86, 91]. Andrés-Martinez et al. [85] use cat-entanglement11 to implement non-local quantum gates. The chosen gate set contains every one-qubit gate and a single two-qubit gate, namely the CZ gate (i.e., the controlled version of the Z gate). The authors consider no restriction on the ebit connectivity between QPUs. Then, they reduce the problem of distributing a circuit across multiple QPUs to hypergraph partitioning. The proposed approach is evaluated against five quantum circuits, including QFT. The proposed solution has some drawbacks, in particular that there is no way to customize the number of communication qubits of each QPU. As previously mentioned, in Sundaram’s et al. paper [86], a two-step quantum compiling approach is introduced. The first step is qubit assignment, while the second step is finding the smallest set of cat-entanglement operations that will enable the execution of all telegates. The authors state that, in a special setting, this problem can be reduced to a vertex-cover problem, allowing for a polynomial-time optimal solution based on integer linear programming. They also provide a 𝑂 (log 𝑛)-approximate solution, where 𝑛 is the total number of global gates, for a generalized setting by means of greedy search algorithm. Also the aforementioned work by Cuomo et al. [91] adopts the telegate approach. 6.3 Open Issues and Research Directions The most advanced quantum compilers for execution on single quantum processors are noise-aware, i.e., they take the noise statistics of the device into account, for some or all steps [45, 95–98]. A noise-aware quantum compiler for DQC is still missing. Indeed, it is still an open question what kind of noise-awareness such a compiler should have. The different options range from a compiler that has complete knowledge of the target execution platform (quantum processors, quantum links, etc.) to a compiler that only knows generic features of the target quantum processors and network – as the execution manager will decide the actual execution platform assigned to the computation. Further work could be done regarding the integration of quantum compilers with simulation tools – in line with the preliminary attempt that was made by Ferrari et al. [99] – allowing for automated workflows that would allow for faster comparative evaluation of compiling strategies. So far, testing the quality of compiled circuits on real execution platforms has not been possible for the majority of researchers. Once a quantum network will be available to the public – much like current IBM Q, Rigetti, etc. single quantum devices – it will be possible to evaluate DQC compilers more effectively , with key performance indicators including the resulting computation quality, state fidelity, and other performance metrics [100].

7 SIMULATION TOOLS To support the research community in the design and evaluation of quantum computing and quantum network technologies, including hardware, protocols and applications, many simulation tools have been developed recently. Simulations are very important for several reasons. First of all, they allow for defining hardware requirements using a top-down approach, i.e., starting from applications and protocols. In this way, hardware design is driven by high-level KPIs (key performance indicators), rather than proceeding by trial and error. Another advantage of simulations is related to network sizing. Given the number of potential users and the number of available quantum processors, simulation allows for devising and evaluating different network topologies and entanglement routing schemes, which results in saving time and money. Regarding DQC, simulation plays a crucial role for establishing the correctness of the compiled distributed quantum programs, and evaluating the quality of their execution against different hardware platforms, network configurations and scheduling algorithms. In Table 4, we compare some prominent simulation tools that, in our view, can be used for designing and evaluating DQC systems. We propose to classify each tool as belonging to one of three possible classes: i) hardware-oriented (HW), ii) protocol-oriented (PR), and iii) applicationoriented (AP). In the remainder of the section, we first present each class with some of the most representative simulation tools. Then, we discuss some open issues. 7.1 Hardware-oriented We denote as HW simulation tools those that allow the user to model the physical entities with the desired degree of detail, including noise models. Prominent examples are SQUANCH [101] and NetSquid [102], discussed in the following. Regarding DQC, we note that HW simulation tools are useful for evaluating the impact of different hardware technologies (including noise models) on the quality of the distributed program execution. The Simulator for Quantum Networks and Channels (SQUANCH) [101] is an open-source Python framework for creating parallelized simulations of distributed quantum information processing. Despite the framework includs many features of a general-purpose quantum computing simulator, it is optimized specifically for simulating quantum networks. It includes functionality to allow users to design complex multi-party quantum networks, extensible classes for modeling noisy quantum channels, and a multiprocessed NumPy backend for performant simulations. The core modules are QSystem, representing a multi-body quantum system as a density matrix in the computational basis, and QStream, which is an iterable ensemble of separable 𝑁 -qubit QSystems optimized for cache locality. By default QStream state is stored in a shared memory as a C-type array of doubles, which is type-casted as a 3D array of np.complex64 values. During simulations, Agents run in parallel from separate processes, synchronizing clocks and passing information between each other through Channels. There is no explicit concurrency safety when a QSystem is modified by multiple agents, as sending and receiving Qubits are blocking operations that allow for naturally safe parallelism. However, the scalability of this simulation tool is hindered by the lack of support for distributed multiprocessing, as all the processes must run on the same machine. The source code is not maintained since 2018. NetSquid [102] is one of the most advanced platforms for simulating quantum networking and modular computing systems subject to physical non-idealities. It ranges from the physical layer and its control plane up to the application level. This is achieved by integrating several key technologies: a discrete-event simulation engine, a specialized quantum computing library, a modular framework for modeling quantum hardware devices, and an asynchronous programming framework for describing quantum protocols. NetSquid has been used for different purposes, such as the evaluation of a benchmarking procedure for quantum protocols [109], the evaluation of endto-end entanglement generation strategies in terms of capacity bounds and impact on Quantum Key Distribution (QKD) [110, 111], and the performance evaluation of request scheduling algorithms for quantum networks [112]. 7.2 Protocol-oriented In the proposed classification, PR simulation tools are mostly devoted to the design and evaluation of general-purpose quantum protocols, – such as quantum state teleportation, quantum leader election, etc. [113] – with the possibility to model hardware-agnostic networked quantum processors, with very limited (if not missing) support for noise modeling. Relevant examples are SimulaQron [103], SeQUeNCe [104], QuiSP [105] and QuNetSim [106]. Regarding DQC, PR simulation tools are useful for evaluating the impact of different compiling and execution management strategies on the quality of the distributed program execution, in (almost) ideal conditions. SimulaQron [103] is a tool for developing distributed software that runs on real or simulated classical and quantum end-nodes, connected by classical and quantum links. SimulaQron spawns three stacked processes per network node: the lowest one for wrapping a simulated quantum registry, based on an hardware-specific third-party simulator; the intermediate process exposing simulated qubits that map 1-to-1 to those of the quantum registry; the upper process providing virtual qubits that are manipulated within a platform-independent application. For example, if two virtual qubits belonging to different processes, running on physically-separated servers, are manipulated in order to share an entangled state (let say, a Bell state), the corresponding simulated qubits (and quantum register ones) are both stored in the memory of one server, in order to make it possible to simulate measurements in a consistent fashion. This process-oriented approach makes SimulaQron quite scalable and able to leverage multicore server architecture in order to speed up the execution of the simulations. However, SimulaQron does not come with noise model support, thus preventing the simulation of quantum protocols over non-ideal networks. SeQUeNCe [104] is an open-source discrete-event quantum network simulator, whose latest release fully supports parallel simulation. The authors designed and developed a quantum state manager (QSM) that maintains shared quantum information distributed across multiple processes, and also optimized their parallel code by minimizing the overhead of the QSM and by decreasing the amount of synchronization among processes. QuiSP [105] is an event-driven Quantum Internet simulation package. QuiSP is built on top of the OMNeT++ discrete event simulation framework. Compared to the simulators discussed so far, many of which focus on physically realistic simulation of a single small network, QuiSP is oriented to protocol design for complex, heterogeneous networks at large scale while keeping the physical layer as realistic as possible. Emphasis has been placed on realistic noise models. The declared long-term goal for the simulator is to be able to handle an internetwork with 100 networks of 100 nodes each. To simulate quantum networks at the cost of only a few classical bits per qubit, QuiSP works in the error basis, i.e., tracking only errors, not states. The premise is that the desired quantum state is known and only deviations from this ideal state must be tracked. This is a novel approach for simulating quantum networks, adapted from quantum error correction [114]. The performance of QuISP was investigated in terms of events processed per second and the duration of CPU time taken to generate one end-to-end Bell pair, using the Docker environment that QuISP provides. It was shown in [105] that the average CPU time (in seconds) per end-to-end Bell pair generated grows no worse than polynomially in the number of quantum repeaters. Increasing the number of repeaters results in longer simulation time in the scaling, as expected. It also emerged that that QuISP might have some kind of unintended overhead which scales linearly on the number of buffer qubits, which the authors expect to fix in a near-term release [105]. QuNetSim [106] implements a layered model of network component objects inspired by the OSI model. In particular, application, transport, and network layers are considered. QuNetSim does not explicitly incorporate features of the link and physical layers. Indeed, QuNetSim relies on open-source qubit simulators that are used to simulate the physical qubits in the network, namely SimulaQron [103], ProjectQ [115] and EQSN [116] (the latter one being the default backend, as it was developed by the QuNetSim team). In QuNetSim, network nodes can run both classical and quantum applications. The transport layer component prepares classical packets, encodes qubits for superdense message transmission, handles the generation of the two correction bits for quantum state teleportation, etc. The network layer component can route classical and quantum information using two internal network graphs and two different routing algorithms. The network component objects are implemented using threading and observing queues. Extensive use of threading allows each task to wait without blocking the main program thread, which simulates the behavior of sending information and waiting for an acknowledgment, or expecting information to arrive for some period of time from another host. QuNetSim works well for small scale simulations using five to ten hosts that are separated by a small number of hops, while it tends to reach its limits when many entangled qubits are being generated across the network with many parallel operations. 7.3 Application-oriented The third class is devoted to AP simulation tools, which are tailored to the design and implementation of quantum network applications. Usually, these tools rely on simulated backends offered by other packages that are not directly accessible to the user – for example, NetQASM SDK [107] relying on NetSquid [102]. Regarding DQC, AP simulation tools are useful for quickly assessing the quality of quantum circuit splits produced by quantum compilers. The execution management scheme (i.e., job scheduling, entanglement routing, etc.) is hidden to the user, which is at most allowed to specify the network topology (from a short list of preconfigured networks) and the values of a few parameters characterizing the hardware of the quantum processors. The process of setting up a simulation requires strong expertise in the simulator itself, thus being inconvenient for those who are only interested in quantum protocol evaluation or in the design of supporting tools such as quantum compilers. Recently, Ferrari et al. [99] presented a software tool, denoted as DQC Executor, that accepts as input the description of the network and the code of the algorithm, and then executes the simulation by automatically constructing the network topology and mapping the computation onto it, in a framework-agnostic way and transparently to the user. The tool is in its early stages and currently supports automatic deployment of distributed quantum algorithms to the NetSquid [102] simulator. The description of the network is provided by the user in a specific YAML format. The distributed algorithm, instead, is defined with the OpenQASM [117] language. NetQASM SDK [107] is a high-level software development kit, in Python, whose purpose is to make easier to write quantum network applications, to simulate them through NetSquid [102] or SimulaQron [103], and (expected in the near future) to execute them on real hardware. Indeed, the quantum programs developed with NetQASM SDK are translated into low-level programs based on the NetQASM language, similar in nature to classical assembly languages. With respect to other QASM languages, NetQASM provides elements for remote entanglement generation. On the other hand, NetQASM contains no provision for classical communication with remote nodes. Synchronization between the NetQASM programs (through classical send/recv primitives) of multiple nodes is the responsibility of the application programmer. The Quantum Network Explorer Application Development Kit (QNE-ADK) [108] allows the user to create applications and experiments and run them on a simulator. When configuring an application, the user specifies the different roles and what types of inputs the application uses. In addition, the user writes the functionality of the application using the NetQASM SDK [107]. When configuring an experiment, the user can give values to the inputs that were specified when creating the application. The user also chooses which channels and nodes are used in the network and which role is linked to which node. Once configured, the experiment is parsed and sent to the NetSquid simulator [102]. QNE-ADK is particularly useful when the application code developed with NetQASM SDK is provided to the user, whose only duty is to configure and perform experiments. Indeed, using the execution environment is straightforward. There is also a visual interface that further simplifies the experiment configuration. Both NetQASM SDK [107] and QNE-ADK [108] are very useful tools. Without them, configuring DQC simulations is quite a complex task. 7.4 Open Issues and Research Directions There is a sufficiently variegated choice of simulation tools for quantum networks and backends to support DQC research, with specialization on hardware, protocols, or applications. On the other hand, a simulation tool allowing for full-stack simulation of large networks is still missing. Such a tool should be support multiprocessing and multithreading, and simple deployment of DQC simulations on high performance computing facilities. Another possible direction is the development of tools for orchestrating DQC simulations, with automated instantiation of simulation objects representing QPUs and quantum network components. Having quantum compilers for DQC in the loop would be also very useful. Last but not least, it would be great to have the possibility to seamlessly replace simulated hardware with real devices. 8 CONCLUSIONS AND FUTURE PERSPECTIVES Here we conclude the survey by first providing an industrial perspective on distributed quantum computing, and then by discussing the possible stages of distributing quantum computing development. 8.1 Industrial and Standardization Perspective A first quantum revolution has already exploited quantum technologies in our everyday life, creating a deep techno-economic and social impact. Today, a second revolution is underway, and it is safe to predict it will have a major impact in many markets, ranging from Telecom and ICT, through Medicine, to Finance and Transportation, and so on. Clearly, significant work is still needed to develop enabling components and systems for DQC. Yet, considering the foreseen industrial opportunities, significant investments are being made worldwide across public and private organizations. One major obstacle on the way of industrial exploitation of distributed quantum computing is that, nowadays, the industry has not yet consolidated around one type of quantum hardware technology. In this scenario, a quantum hardware abstraction layer (Quantum-HAL) – embracing the two killer domains of quantum technologies for ICT, namely, quantum computing and quantum networking – would allow applications and services developers to start using the abstractions of the underneath quantum hardware, even if still under consolidation. This would definitely simplify and speed-up the development of quantum platforms, services, and applications. Indeed, a Quantum-HAL for distributed quantum computing would provide unified northbound quantum application programming interfaces (APIs) for the higher layers, decoupling from the different types of quantum hardware technologies (e.g., trapped ions, superconducting qubits, silicon photonic qubits). Another key aspect for increasing the TRL (Technology Readiness Level) of distributed quantum computing concerns its integration with current Telecom and ICT infrastructures. This implies the definition and standardization of a management and control approach (architectures and APIs) able of interworking with current solutions. All these activities require coordinated and joint efforts including – where appropriate – existing projects, industry bodies and standard (ITU-T, ETSI, IETF and IEEE just to mention a few) active in the area of quantum technologies. Overall, the final goal is to bridge the gap between DQC and the established cloud and edge computing platforms, tools and methods, and to focus in on the inter-related constraints between the different aspects of the architectural design, so to enable the development of practical DQC solutions. To achieve this goal, research and innovation activities are required in diverse and complementary fields, ranging from computational complexity and networked systems through quantum information and optics to communications and computer science engineering. 8.2 The Journey Ahead Paving a journey towards distributed quantum computing is a challenging task, as hard as any other prediction about technological developments. Yet, we can sketch roughly three stages, as discussed in the following and summarized with Figure 18. The first step involves distributed quantum computing exploiting multiple quantum processors within a single quantum computer. The quantum hardware underlying the qubits is likely to be homogeneous among the different processors. Yet, some sort of hardware heterogeneity may arise within each processor due to the differences in terms of requirements20 between memory qubits and computational qubits. The physical distance between remote qubits is clearly very short. Hence, it is reasonable to assume, as communication infrastructure, short-range microwave links. The network topology is likely static, so that only simple quantum network functionalities are required. Clearly, quantum decoherence must be carefully accounted for, so that the decoherence time can be used as overall key metric. Local operations between qubits within a single processor must be complemented by remote operations between qubits placed at different processors. The trade-off between qubits devoted to computation and entangled qubits devoted to communication represents a fundamental issue with no counterpart in classical distributed computing. The very challenging task of designing distributed quantum algorithms must explicitly take such trade-off – as well as the delay induced by remote operations – into consideration. The second step involves inter-rack distributed quantum computing, where the computation is performed collectively by multiple quantum computers located within the same farm. At this stage, some sort of hardware heterogeneity might arise, given that different quantum computers are involved in the computation. Clearly, such heterogeneity must be taken into consideration at each layer of a distributed quantum computing ecosystem. Yet, entanglement distribution still benefits from a tightly controlled environment – reasonable to assume available within a single quantum farm – and the relatively short distances. As a matter of fact, the communication infrastructure can still be composed by cold microwave links [118] although optical links would greatly simplify the hardware requirements albeit at the price of significant technological advances in the microwaveoptical conversion. Delay imposed by classical and quantum communication times is slightly longer – when compared to stage one – hence more sophisticated timing and synchronization functionalities are required. The network topology becomes more complex, and it may present some sort of temporal dynamics as the number of interconnected quantum computers might change in time. This, in turn, induces network functionalities dynamics that must be carefully taken into account. The problem of remote operations compiling – and, hence, the trade-off between computational and communication qubits – becomes even more intricate. Finally, at this stage, the execution management problem (previously discussed in Section 4.2) will arise, with multiple users performing concurrent access to the resources. The third step involves interconnecting multiple geographically-distributed quantum farms. Two are the key challenges here. First, there exists a likely spread heterogeneity – given that the different quantum farms will be likely operated by different companies –, which requires significant efforts in terms of standardization and interoperability. Furthermore, the heterogeneity among quantum links, e.g., optical, free-space or satellite, will arise. The delays induced by the distances will introduce severe challenges on the entanglement generation and distribution. The increasing number of quantum devices to be wired and the heterogeneity of the environments hosting the quantum computers must be taken into account as well. At this stage, the compiling and execution management problems would be even more complex, demanding for specific network services to be integrated with those of the classical Internet (such as DNS, DHCP, etc.). We underline that, although each successive stage is distinguished by an increasing amount of interconnected quantum resources, the actual deployment evolution will strongly depend on the technological advances and the experimental implementations of the different entities composing a distributed quantum computing ecosystem [12]. One of the judicious questions raised from this discussion is: when will we see the distributed quantum computing? There is no definite answer to this question. However, we firmly believe this is a goal that requires a collaborative effort and a multi-disciplinary approach between academics and industries. The required competences and skills are many and diverse and each is interconnected with and vital to the others.