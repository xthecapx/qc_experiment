\section*{Background}
\label{sec:background}

\subsection*{Pre-runtime and Post-runtime metrics}

In order to understand the complexities associated with benchmarking a QPU, it is fundamental to first analyze the procedure adopted by developers in quantum computing (QC), which can be generally categorized into two overarching steps.

In the first step, developers prepare quantum states by applying a combination of quantum gates to a set of qubits.  This process is analogous to the creation of classical computer pseudocodes. Once the quantum algorithm is ready, it is coded using a library such as Qiskit, Q\#, or PennyLane, which is equivalent to using a programming language like Prolog or a hardware description language like VHDL or Verilog. The result of this step is known as a quantum circuit and serves as the basis for the next step.

In the second step, the circuit is run on a QPU and measurements are collected. It is important to note that before reaching the runtime service, the circuit is transpiled and optimized to match the target quantum chip. The process is equivalent to optimizing high-level programming languages before converting them into CPU instructions.

Alternatively, as an intermediate step, developers may run the circuit on a quantum simulator. However, the number of qubits that can be simulated using classical hardware is limited; for example, simulating 30 qubits requires 16 GB of RAM \cite{BenchmarkingSimulatedPhysical}, and even with parallel processing, this limit increases only up to about 240 qubits \cite{zhouWhatLimitsSimulation_2020}.

In accordance with this workflow, which spans from the development of the circuit to its execution on a QPU or simulator, it is possible to differentiate between pre-runtime and post-runtime metrics.

\subsubsection*{Pre-runtime metrics}

The pre-runtime metrics are computed after coding the algorithm and before executing the quantum circuit.

The literature highlights that metrics commonly used in classical computing are also applicable to quantum computing, along with a few metrics that are unique to the quantum domain. A number of metrics identified in published research align with our definition of pre-runtime metrics, and we categorize them into the following two groups:

\textit{Maintainability metrics}. This category addresses the practical, long-term aspects of developing QC algorithms. Maintainability metrics help quantify the effort and resources required to understand, modify, and manage a quantum program throughout its lifecycle.

Included in maintainability metrics are the economic cost associated with the escalation of quantum infrastructure \cite{Moguel2022}, the number of gates employed per qubit during specific stages of the circuit, known as circuit density \cite{cruz_lemusQuantumSoftwareQuality_2024}, and oracle-related evaluations related to operations that serve as input for other quantum algorithms \cite{cruz_lemusQuantumSoftwareQuality_2024}.

\textit{Circuit complexity metrics}. These metrics provide a hardware-agnostic characterization of the fundamental structure and resource requirements of the QC circuits. They measure the complexity of the algorithm itself, offering information on how demanding a circuit will be to execute, regardless of the specific QPU used.

The evaluation of complexity metrics encompasses a range of structural and operational measures, most of which are described by Cruz-Lemus et al. \cite{cruz_lemusQuantumSoftwareQuality_2024}. Structural metrics include circuit width (CW), which measures the total number of qubits, and circuit depth (CD), which represents the longest path from input to output. They also cover the complexity of circuit gates (CCG) to assess the intricacy of gate operations, conditional instructions (CI) to quantify classical control flow, and quantum cyclomatic complexity (QCC) as a measure of a program's structural complexity. Operational metrics further track the number of measurement operations (MO), initial and reset operations (IRO), and any auxiliary qubits (AQ) required for the computation.

\subsubsection*{Post-runtime metrics}

The post-runtime metrics are computed from the QPU results, which in some cases involves creating a correlation with the pre-runtime metrics. The literature highlights a variety of metrics that are consistent with our definition. We categorize them into the following groups:

\textit{Performance-related metrics}. This group assesses the overall effectiveness of the QC algorithm in solving a given task. They answer questions about the quality, reliability, and speed of the results produced by the QPU.

Performance metrics include evaluations of task-solving efficiency, such as quantum volume and the total quantum factor \cite{salmCriterionSuccessfullyExecuting_2020}. The quality of the results is assessed through precision, which examines the degree to which repeated measurements are related, and accuracy, which determines the degree to which the results are related to the true value \cite{litinskiMagicStateDistillation2019_2019}. Furthermore, crucial operational aspects are evaluated by measuring decoherence, representing information lost to environmental factors \cite{sainiCurrentChallengeLimitationsa_2023}, and the response times between a request and its result \cite{Moguel2022}. An overview of these performance metrics is available in \cite{wangSoKBenchmarkingPerformance_2022, wackQualitySpeedScale_2021}.

\textit{Hardware quality metrics}. Unlike algorithmic performance, these metrics evaluate the intrinsic physical properties of the quantum hardware itself.

Hardware quality metrics include physical measurements such as T1 (energy relaxation, "the time needed for a qubit to move from the excited state $\ket{1}$ to the ground state $\ket{0}$" \cite{youssefMeasuringSimulatingT12020}) and T2 (dephasing, "the elapsed time before a qubit's resonance frequency becomes unidentified" \cite{youssefMeasuringSimulatingT12020, Alam2019}). In addition, the reliability of the system is often determined by error measurements, particularly noise characterization in quantum gates \cite{tripathiBenchmarkingQuantumGates_2025}.

\textit{Correctness and Error metrics}. This category focuses on the ultimate outcome of a quantum computation: its success. These metrics directly quantify how often a circuit execution yields the correct result, thereby offering a fundamental measure of the system's capability to perform reliable computations.

The correctness and error metrics mainly evaluate the success rate \cite{bandicProfilingQuantumCircuits_2024} and the fidelity of the circuit \cite{emersonScalableNoiseEstimation_2005}. The most common protocol for calculating them is Randomized Benchmarking (RB), which, in summary, creates random circuits, applies a mirror circuit, and expects to obtain the identity matrix after measurement \cite{knillRandomizedBenchmarkingQuantum2008_2008}.

\subsection*{Benchmarking variants}

In their "Systematic Review of Quantum Benchmarking" \cite{malhotraSystematicReviewQuantum_2024}, Pranit et al. identify several benchmarking variants used to assess the performance and reliability of QPUs. The principal variants are outlined as follows.

\subsubsection*{Randomized Benchmarking (RB):}

RB is a protocol used to estimate the average error rates of quantum circuits by applying sequences of randomly chosen gates (typically from the Clifford group) and observing the decay in success rate, error propagation, and/or gate fidelity as the size of the generated random circuit increases \cite{knillRandomizedBenchmarkingQuantum2008_2008}. The authors highlight that RB is robust to "state preparation and measurement" (SPAM) errors and scalable to larger systems \cite{malhotraSystematicReviewQuantum_2024}.

In this research, we used elements of RB since it aligns with our definitions of pre-runtime and post-runtime. More precisely, RB provides a framework for analyzing quantum circuits using pre-runtime metrics such as gate count, circuit depth, and Clifford group composition, and to monitor its correlation with post-runtime metrics such as execution time and success rate \cite{malhotraSystematicReviewQuantum_2024}.

\subsubsection*{Application-Oriented Benchmarking:}

This approach focuses on running known quantum algorithms to assess QPU performance and utility \cite{malhotraSystematicReviewQuantum_2024}. The idea behind this benchmarking method is to compare measurements with theoretical results.

In this study, we chose not to use application-oriented benchmarking. While this approach provides valuable insights through pre-runtime metrics based on known algorithms, our research supports the utilization of random circuits, as their inherently arbitrary characteristics offer a more rigorous evaluation for a general-purpose transfer protocol analogous to ours.

\subsubsection*{Volumetric Benchmarking:}

In this method, a QPU is mapped using random quantum circuits with varying widths (number of qubits) and depths (number of gate layers) \cite{malhotraSystematicReviewQuantum_2024}. Due to the nature of volumetric benchmarking, which is intended to evaluate hardware, no elements of this group are included in this study.

\subsubsection*{Quantum Tomography:}

Quantum tomography is a set of techniques that are used to characterize quantum systems by reconstructing their quantum states or operations \cite{knillRandomizedBenchmarkingQuantum2008_2008}. There are three types of post-runtime metrics in this group: state tomography, which reconstructs a quantum state's density matrix; process tomography, which characterizes quantum operations; and gate set tomography, which describes a set of quantum gates in a self-consistent way \cite{malhotraSystematicReviewQuantum_2024}. 

These benchmarking methods provide detailed information on quantum states and operations. However, they are resource-intensive and require a large number of measurements, which makes them less scalable for large quantum systems \cite{knillRandomizedBenchmarkingQuantum2008_2008}. Furthermore, they are not directly controllable at the software layer, as they require specific hardware configurations and measurement protocols \cite{malhotraSystematicReviewQuantum_2024}. Due to these factors, we do not take into account variants from this group in our study.

\subsubsection*{Cycle Benchmarking:}

Cycle benchmarking is a protocol that repeatedly applies quantum gates to amplify and characterize errors in a quantum system \cite{malhotraSystematicReviewQuantum_2024}. This approach allows for systematic analysis of errors in quantum circuits. The method is particularly useful for understanding how errors affect circuit success rates, as it provides a direct measurement of error rates by repeatedly applying the same gates to a qubit \cite{knillRandomizedBenchmarkingQuantum2008_2008}.

Considering the nature of understanding system errors, we incorporate cycle benchmarking methods into our study. To be more precise, we apply gates to each qubit of the payload and calculate the success rate and associated error for each shot within and throughout jobs.

\subsubsection*{Miscellaneous/Hybrid Approaches:}

Hybrid protocols are those that combine components from previously described benchmark variants. Several protocols fit this group, including hybrid benchmarking, which combines classical and quantum components, matchgate benchmarking, which focuses on specific gate sets, and random circuit sampling, which incorporates elements of RB with application-specific metrics \cite{chasseurHybridBenchmarkingArbitrary_2017}.

In the present study, we propose a benchmarking method that fits within the hybrid category by integrating three key components: TP inspired algorithm for quantum state transfer, cycle benchmarking for error characterization, and RB for success rate. 

\subsection*{The teleportation protocol (TP)}

TP is a well-defined procedure ---introduced by Bennett et al. \cite{bennettTeleportingUnknownQuantum_1993} in 1993--- that typically involves three qubits: one holding the message to be teleported (Alice's message qubit, M) and two others forming an entangled pair. The protocol assumes that Alice and Bob are physically separated; Alice possesses one qubit from the entangled pair (qubit A), and Bob holds the other (qubit B). In addition, a classical communication channel between them is mandatory.

TP proceeds as follows: Initially, Alice performs operations to entangle her message qubit (M) and her own qubit (A), which was previously entangled with Bob's qubit (B). She then measures these two qubits (M and A). This measurement projects their combined quantum states onto a definite classical outcome, which yields two classical bits of information, but, in doing so, irreversibly alters the original states of M and A. Following this, Alice communicates these classical bits to Bob. Based on the information received, Bob applies a specific set of corrective unitary operations to his qubit (B), and as a result, he recreates the original quantum state of Alice's message (M) on his qubit.

\subsubsection*{Mathematical description of TP}

The teleportation protocol proceeds through a series of well-defined quantum operations. The process begins with a formal definition of the quantum state pertaining to Alice's message qubit as:

\begin{equation}
\ket{\psi}_M = \alpha\ket{0} + \beta\ket{1}
\label{eq:teleportation_initial_state}
\end{equation}

Initially, Alice's qubit (A) and Bob's qubit (B) are prepared in the $\ket{0}$ state. To create the necessary entanglement between Alice and Bob, a Hadamard gate is applied to Alice's qubit followed by a CNOT gate with Alice's qubit as control and Bob's as target:

\begin{equation}
\begin{split}
\text{CNOT}_{AB} H_A \ket{0}_B\ket{0}_A &= \text{CNOT}_{AB} \ket{0}_B \frac{1}{\sqrt{2}}(\ket{0}_A + \ket{1}_A) \\
&= \text{CNOT}_{AB} \frac{1}{\sqrt{2}}(\ket{00}_{AB} + \ket{01}_{AB}) \\
&= \frac{1}{\sqrt{2}}(\ket{00}_{AB} + \ket{11}_{AB}) = \ket{\Phi^+}_{AB}
\end{split}
\end{equation}

At this point, the message qubit M is independent of the entangled pair, so the combined three-qubit state can be written as:

\begin{equation}
\ket{\psi}_M \otimes \ket{\Phi^+}_{AB} = \frac{1}{\sqrt{2}}(\alpha\ket{0}_M + \beta\ket{1}_M)(\ket{00}_{AB} + \ket{11}_{AB})
\label{eq:ab_initial_state}
\end{equation}

Equation \ref{eq:ab_initial_state} denotes the initial state of the three qubits before Allice performs a measurement. Notice that the M qubit remains independent of the entangled pair AB, as they have not yet interacted. This is the starting point for the Allice teleportation operation.

Expanding equation \ref{eq:ab_initial_state} on the computational basis with qubits ordered as M, A, B:

\begin{equation}
\ket{\psi_{MAB}} = \frac{1}{\sqrt{2}}(\alpha\ket{000} + \alpha\ket{011} + \beta\ket{100} + \beta\ket{111})
\end{equation}

Alice now performs the measurement operation by applying a CNOT gate with M as control and A as target, followed by a Hadamard gate on M. The CNOT operation yields the following.

\begin{equation}
\text{CNOT}_{MA}\ket{\psi_{MAB}} = \frac{1}{\sqrt{2}}(\alpha\ket{000} + \alpha\ket{011} + \beta\ket{110} + \beta\ket{101})
\end{equation}

Applying the Hadamard gate to qubit M:

\begin{equation}
\begin{split}
H_M(\text{CNOT}_{MA}\ket{\psi_{MAB}}) &= \frac{1}{2}[\alpha(\ket{0}+\ket{1})\ket{00} + \alpha(\ket{0}+\ket{1})\ket{11} \\ 
& + \beta(\ket{0}-\ket{1})\ket{10} + \beta(\ket{0}-\ket{1})\ket{01}]
\end{split}
\end{equation}

Expanding and regrouping terms according to the measurement outcomes of qubits M and A:

\begin{equation}
\begin{split}
\ket{\psi_{MAB}} &= \frac{1}{2}[\ket{00}_{MA}(\alpha\ket{0}_B + \beta\ket{1}_B) + \ket{01}_{MA}(\alpha\ket{1}_B + \beta\ket{0}_B) \\ 
& + \ket{10}_{MA}(\alpha\ket{0}_B - \beta\ket{1}_B) + \ket{11}_{MA}(\alpha\ket{1}_B - \beta\ket{0}_B)]
\end{split}
\label{eq:teleportation_grouped_state}
\end{equation}

This expression reveals that when Alice measures qubits M and A, she obtains one of four equally probable outcomes (each with probability $\frac{1}{4}$), and each measurement outcome projects Bob's qubit into a corresponding state. The relationship between Alice's measurement results and Bob's resulting states is summarized in Table~\ref{tab:teleportation_state_propagation}.

\renewcommand{\arraystretch}{1.3}
\setlength{\tabcolsep}{8pt}
\begin{table}[ht]
    \centering
    \begin{tabular}{|c|c|c|c|c|}
    \hline
    \textbf{\shortstack{Initial State \\ (\(\ket{\psi}\))}} & \textbf{\shortstack{Alice's \\ Measurement}} & \textbf{\shortstack{Bob's State \\ (Before \\ Correction)}} & \textbf{\shortstack{Operation \\ by Bob}} & \textbf{\shortstack{Bob's Final \\ State}} \\ \hline
    \(\alpha\ket{0} + \beta\ket{1}\) & \(\ket{00}_{MA}\) & \(\alpha\ket{0} + \beta\ket{1}\) & None (I) & \(\alpha\ket{0} + \beta\ket{1}\) \\ \hline
    \(\alpha\ket{0} + \beta\ket{1}\) & \(\ket{01}_{MA}\) & \(\alpha\ket{1} + \beta\ket{0}\) & X & \(\alpha\ket{0} + \beta\ket{1}\) \\ \hline
    \(\alpha\ket{0} + \beta\ket{1}\) & \(\ket{10}_{MA}\) & \(\alpha\ket{0} - \beta\ket{1}\) & Z & \(\alpha\ket{0} + \beta\ket{1}\) \\ \hline
    \(\alpha\ket{0} + \beta\ket{1}\) & \(\ket{11}_{MA}\) & \(\alpha\ket{1} - \beta\ket{0}\) & XZ & \(\alpha\ket{0} + \beta\ket{1}\) \\ \hline
    \end{tabular}
    \caption{Bob's corrective Pauli operations based on Alice's measurement outcome (communicated classically) to recover the initial quantum message \(\ket{\psi}\).}
    \label{tab:teleportation_state_propagation}
\end{table}

It is worth noting that Equation~\ref{eq:teleportation_grouped_state} can be equivalently represented within the Bell basis as:

\begin{equation}
\begin{split}
\ket{\psi_{MAB}} &= \frac{1}{2}[\ket{\Phi^+}_{MA}(\alpha\ket{0} + \beta\ket{1})_B + \ket{\Phi^-}_{MA}(\alpha\ket{0} - \beta\ket{1})_B \\ 
&+ \ket{\Psi^+}_{MA}(\alpha\ket{1} + \beta\ket{0})_B + \ket{\Psi^-}_{MA}(\alpha\ket{1} - \beta\ket{0})_B]
\end{split}
\label{eq:teleportation_bell_basis}
\end{equation}

where the Bell states are defined as:

\begin{equation}
\begin{aligned}
\ket{\Phi^+}_{MA} &= \frac{1}{\sqrt{2}}(\ket{00} + \ket{11})_{MA} \\
\ket{\Phi^-}_{MA} &= \frac{1}{\sqrt{2}}(\ket{00} - \ket{11})_{MA} \\
\ket{\Psi^+}_{MA} &= \frac{1}{\sqrt{2}}(\ket{01} + \ket{10})_{MA} \\
\ket{\Psi^-}_{MA} &= \frac{1}{\sqrt{2}}(\ket{01} - \ket{10})_{MA}
\end{aligned}
\label{eq:bell_states}
\end{equation}

It is possible to calculate the inverse transformation from computational basis to Bell basis and update the equation \ref{eq:teleportation_grouped_state}.

\begin{equation}
\begin{aligned}
\ket{00}_{MA} &= \frac{1}{\sqrt{2}}(\ket{\Phi^+} + \ket{\Phi^-})_{MA} \\
\ket{11}_{MA} &= \frac{1}{\sqrt{2}}(\ket{\Phi^+} - \ket{\Phi^-})_{MA} \\
\ket{01}_{MA} &= \frac{1}{\sqrt{2}}(\ket{\Psi^+} + \ket{\Psi^-})_{MA} \\
\ket{10}_{MA} &= \frac{1}{\sqrt{2}}(\ket{\Psi^+} - \ket{\Psi^-})_{MA}
\end{aligned}
\label{eq:computational_to_bell}
\end{equation}

Equation \ref{eq:teleportation_bell_basis} is the Bell base representation, which highlights the essential framework of the TP.

It is important to note that the efficacy of the protocol is dependent on a classical communication channel. Specifically, Alice is required to transmit her measurement outcome to Bob, enabling him to execute the corresponding corrective operation. This classical communication requirement ensures that no information is transmitted faster than the speed of light, thereby maintaining consistency with the principles of relativistic causality.

The circuit diagram of TP can be visualized in the figure \ref{fig:teleportation_algorithm}.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.9\textwidth]{teleportation_circuit_grayscale.png}
    \caption{A visual representation of TP's quantum circuit. Notice how the last two gates have a conditional operation based on the observation result.}
    \label{fig:teleportation_algorithm}
\end{figure}

To close this section, it is pertinent to acknowledge the complexities inherent in executing the teleportation protocol in practical scenarios. In addition to the challenges related to the loss incurred during the separation of entangled qubits, there must also be an active classical communication channel available. However, existing literature has documented the successful transmission of a single photon across a distance exceeding 14,000 km utilizing a ground-to-satellite quantum teleportation system \cite{renGroundtosatelliteQuantumTeleportation_2017}.
